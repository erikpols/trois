import{toRef as ze,watch as u,ref as is,defineComponent as a,watchEffect as ns,inject as X,provide as os,getCurrentInstance as as,onUnmounted as hs,createApp as ds}from"https://unpkg.com/vue@3.2.20/dist/vue.esm-browser.prod.js";import{Vector3 as de,Raycaster as us,Plane as cs,Vector2 as A,InstancedMesh as te,WebGLRenderer as ls,OrthographicCamera as ms,PerspectiveCamera as ps,Scene as fs,Color as re,Texture as ys,Group as gs,WebGLCubeRenderTarget as bs,RGBAFormat as vs,LinearMipmapLinearFilter as Ss,CubeCamera as Ps,Mesh as ws,BufferGeometry as xs,BufferAttribute as Cs,BoxGeometry as Re,CircleGeometry as Ms,ConeGeometry as Gs,CylinderGeometry as Ls,DodecahedronGeometry as Ns,ExtrudeGeometry as je,IcosahedronGeometry as Os,LatheGeometry as $s,OctahedronGeometry as Es,PlaneGeometry as Ie,PolyhedronGeometry as zs,RingGeometry as Rs,SphereGeometry as js,ShapeGeometry as Is,TetrahedronGeometry as ks,TorusGeometry as _s,TorusKnotGeometry as Ts,CatmullRomCurve3 as ke,Curve as As,TubeGeometry as Bs,SpotLight as Pe,DirectionalLight as we,AmbientLight as Ds,HemisphereLight as Fs,PointLight as Us,RectAreaLight as Hs,MeshBasicMaterial as _e,MeshLambertMaterial as Vs,MeshPhongMaterial as Ks,MeshPhysicalMaterial as Xs,PointsMaterial as qs,ShadowMaterial as Ws,MeshStandardMaterial as Zs,MeshToonMaterial as Ys,TextureLoader as se,MeshMatcapMaterial as Js,ShaderMaterial as xe,ShaderChunk as q,UniformsUtils as Te,ShaderLib as Qs,CubeReflectionMapping as ei,CubeTextureLoader as ti,VideoTexture as ri,DoubleSide as si,SpriteMaterial as ii,Sprite as ni,Points as oi,GridHelper as ai}from"https://cdn.skypack.dev/three@0.136.0/build/three.module.js";import{OrbitControls as hi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js";import{mergeBufferGeometries as di}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/utils/BufferGeometryUtils";import{RectAreaLightUniformsLib as ui}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as ci}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/helpers/RectAreaLightHelper.js";import{TextGeometry as li}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/TextGeometry.js";import{FontLoader as mi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js";import{GLTFLoader as pi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as fi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as yi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as gi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as bi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as vi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as ue}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as Si}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as Pi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as wi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as xi}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as Ci}from"https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js";function W(e,t,r){t instanceof Object&&Object.entries(t).forEach(([s,i])=>{r?r(e,s,i):e[s]=i})}function B(e,t,r,s=!0,i){s&&W(r,e[t],i);const n=ze(e,t);return u(n,o=>{W(r,o,i)})}function Ae(e,t,r=!0,s){r&&W(t,e,s);const i=is(e);return u(i,n=>{W(t,n,s)},{deep:!0})}function Z(e,t){t instanceof Object&&Object.entries(t).forEach(([r,s])=>{e[r]=s})}function Be(e,t,r){t.forEach(s=>{y(e,s,r,s)})}function y(e,t,r,s){const i=s||t,n=ze(e,t);n.value instanceof Object?(Z(r[i],n.value),u(n,o=>{Z(r[i],o)},{deep:!0})):(n.value!==void 0&&(r[i]=e[t]),u(n,o=>{r[i]=o}))}function ie(e,t=[]){const r={};return Object.entries(e).forEach(([s,i])=>{(!t||!t.includes(s))&&(r[s]=i)}),r}function De(e,t,r){return r=r<0?0:r,r=r>1?1:r,e+(t-e)*r}function Fe(e,t,r){return e<t?t:e>r?r:e}const Mi="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d",Gi="0404E8_0404B5_0404CB_3333FC";function Ce(e=Gi,t=1024){const r=`${e}${Li(t)}.png`;return`${Mi}/${t}/${r}`}function Li(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}function Ni(e){const{camera:t,resetPosition:r=new de(0,0,0)}=e,s=new us,i=r.clone(),n=new cs(new de(0,0,1),0);return{position:i,updatePosition:o=>{s.setFromCamera(o,t),t.getWorldDirection(n.normal),s.ray.intersectPlane(n,i)},intersect:(o,p,$=!1)=>(s.setFromCamera(o,t),s.intersectObjects(p,$))}}function Ue(e){const{camera:t,domElement:r,intersectObjects:s,intersectRecursive:i=!1,touch:n=!0,resetOnEnd:o=!1,onEnter:p=()=>{},onMove:$=()=>{},onDown:E=()=>{},onUp:v=()=>{},onLeave:z=()=>{},onClick:_=()=>{},onIntersectEnter:C=()=>{},onIntersectOver:D=()=>{},onIntersectMove:F=()=>{},onIntersectLeave:j=()=>{},onIntersectUp:T=()=>{},onIntersectDown:U=()=>{},onIntersectClick:h=()=>{}}=e,d=new A(0,0),l=new A(0,0),S=Ni({camera:t}),H=S.position,ve={position:d,positionN:l,positionV3:H,intersectObjects:s,listeners:!1,addListeners:rs,removeListeners:ss,intersect:Ge};return ve;function ts(){d.set(0,0),l.set(0,0),H.set(0,0,0)}function Q(m){let g,L;m.touches&&m.touches.length>0?(g=m.touches[0].clientX,L=m.touches[0].clientY):(g=m.clientX,L=m.clientY);const M=r.getBoundingClientRect();d.x=g-M.left,d.y=L-M.top,l.x=d.x/M.width*2-1,l.y=-(d.y/M.height)*2+1,S.updatePosition(l)}function Ge(){const m=he();if(m.length){const g=S.intersect(l,m,i),L=[...m],M=[];g.forEach(x=>{var N,b,c;const{object:f}=x,P=ee(f);if(f instanceof te){if(M.indexOf(f)!==-1)return;M.push(f)}if(!f.userData.over){f.userData.over=!0;const Se={type:"pointerover",over:!0,component:P,intersect:x},Ee={...Se,type:"pointerenter"};D(Se),C(Ee),(N=P==null?void 0:P.onPointerOver)==null||N.call(P,Se),(b=P==null?void 0:P.onPointerEnter)==null||b.call(P,Ee)}const $e={type:"pointermove",component:P,intersect:x};F($e),(c=P==null?void 0:P.onPointerMove)==null||c.call(P,$e),L.splice(L.indexOf(f),1)}),L.forEach(x=>{var N,b;const c=ee(x);if(x.userData.over){x.userData.over=!1;const f={type:"pointerover",over:!1,component:c},P={...f,type:"pointerleave"};D(f),j(P),(N=c==null?void 0:c.onPointerOver)==null||N.call(c,f),(b=c==null?void 0:c.onPointerLeave)==null||b.call(c,P)}})}}function ne(m){Q(m),p({type:"pointerenter",position:d,positionN:l,positionV3:H})}function oe(m){Q(m),$({type:"pointermove",position:d,positionN:l,positionV3:H}),Ge()}function Le(m){Q(m);const g=he();if(g.length){const L=S.intersect(l,g,i),M=[];L.forEach(x=>{var N;const{object:b}=x,c=ee(b);if(b instanceof te){if(M.indexOf(b)!==-1)return;M.push(b)}const f={type:"pointerdown",component:c,intersect:x};U(f),(N=c==null?void 0:c.onPointerDown)==null||N.call(c,f)})}E({type:"pointerdown",position:d,positionN:l,positionV3:H})}function Ne(m){Q(m);const g=he();if(g.length){const L=S.intersect(l,g,i),M=[];L.forEach(x=>{var N;const{object:b}=x,c=ee(b);if(b instanceof te){if(M.indexOf(b)!==-1)return;M.push(b)}const f={type:"pointerup",component:c,intersect:x};T(f),(N=c==null?void 0:c.onPointerUp)==null||N.call(c,f)})}v({type:"pointerup",position:d,positionN:l,positionV3:H})}function Oe(m){var g;Q(m);const L=he();if(L.length){const M=S.intersect(l,L,i),x=[];let N=1/0,b=null;for(let c of M)c.distance<N&&(b=c);if(b){const{object:c}=b,f=ee(c);if(c instanceof te){if(x.indexOf(c)!==-1)return;x.push(c)}const P={type:"click",component:f,intersect:b};h(P),(g=f==null?void 0:f.onClick)==null||g.call(f,P)}}_({type:"click",position:d,positionN:l,positionV3:H})}function ae(){o&&ts(),z({type:"pointerleave"})}function ee(m){if(m.userData.component)return m.userData.component;let g=m.parent;for(;g;){if(g.userData.component)return g.userData.component;g=g.parent}}function he(){return typeof s=="function"?s():s}function rs(){r.addEventListener("mouseenter",ne),r.addEventListener("mousemove",oe),r.addEventListener("mouseleave",ae),r.addEventListener("pointerdown",Le),r.addEventListener("pointerup",Ne),r.addEventListener("click",Oe),n&&(r.addEventListener("touchstart",ne),r.addEventListener("touchmove",oe),r.addEventListener("touchend",ae)),ve.listeners=!0}function ss(){r.removeEventListener("mouseenter",ne),r.removeEventListener("mousemove",oe),r.removeEventListener("mouseleave",ae),r.removeEventListener("pointerdown",Le),r.removeEventListener("pointerup",Ne),r.removeEventListener("click",Oe),r.removeEventListener("touchstart",ne),r.removeEventListener("touchmove",oe),r.removeEventListener("touchend",ae),ve.listeners=!1}}function Oi(e){const t={antialias:!0,alpha:!1,autoClear:!0,orbitCtrl:!1,pointer:!1,resize:!1,width:300,height:150};e&&Object.entries(e).forEach(([h,d])=>{t[h]=d});const r={width:1,height:1,wWidth:1,wHeight:1,ratio:1},s=[],i=[],n=p(),o={config:t,renderer:n,size:r,init:$,dispose:F,render:z,renderC:_,setSize:T,addIntersectObject:C,removeIntersectObject:D};return o;function p(){const h=new ls({canvas:t.canvas,antialias:t.antialias,alpha:t.alpha,...t.params});return h.autoClear=t.autoClear,h}function $(){if(!o.scene)return console.error("Missing Scene"),!1;if(!o.camera)return console.error("Missing Camera"),!1;if(t.resize?(j(),window.addEventListener("resize",j)):t.width&&t.height&&T(t.width,t.height),E(),t.orbitCtrl){const h=new hi(o.camera,o.renderer.domElement);t.orbitCtrl instanceof Object&&Object.entries(t.orbitCtrl).forEach(([d,l])=>{h[d]=l}),v(()=>{h.update()}),o.cameraCtrl=h}return!0}function E(){let h={camera:o.camera,domElement:o.renderer.domElement,intersectObjects:i};t.pointer&&t.pointer instanceof Object&&(h={...h,...t.pointer});const d=o.pointer=Ue(h);(t.pointer||i.length)&&(d.addListeners(),h.intersectMode==="frame"&&v(d.intersect))}function v(h){s.push(h)}function z(){s.forEach(h=>h()),o.renderer.render(o.scene,o.camera)}function _(){s.forEach(h=>h()),o.composer.render()}function C(h){i.indexOf(h)===-1&&i.push(h),o.pointer&&!o.pointer.listeners&&o.pointer.addListeners()}function D(h){const d=i.indexOf(h);d!==-1&&i.splice(d,1),o.pointer&&!t.pointer&&i.length===0&&o.pointer.removeListeners()}function F(){window.removeEventListener("resize",j),o.pointer&&o.pointer.removeListeners(),o.cameraCtrl&&o.cameraCtrl.dispose(),o.renderer&&o.renderer.dispose()}function j(){var h;if(t.resize==="window")T(window.innerWidth,window.innerHeight);else{const d=o.renderer.domElement.parentNode;d&&T(d.clientWidth,d.clientHeight)}(h=t.onResize)==null||h.call(t,r)}function T(h,d){r.width=h,r.height=d,r.ratio=h/d,o.renderer.setSize(h,d,!1);const l=o.camera;if(l.type==="PerspectiveCamera"){const S=l;S.aspect=r.ratio,S.updateProjectionMatrix()}if(l.type==="OrthographicCamera"){const S=l;r.wWidth=S.right-S.left,r.wHeight=S.top-S.bottom}else{const S=U();r.wWidth=S[0],r.wHeight=S[1]}}function U(){const h=o.camera,d=h.fov*Math.PI/180,l=2*Math.tan(d/2)*Math.abs(h.position.z);return[l*h.aspect,l]}}const R=Symbol("Renderer");var He=a({name:"Renderer",props:{params:{type:Object,default:()=>({})},antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,pixelRatio:Number,xr:Boolean,props:{type:Object,default:()=>({})},onReady:Function},inheritAttrs:!1,setup(e,{attrs:t}){const r=[],s=[],i=[],n=[],o=[],p=document.createElement("canvas");Object.entries(t).forEach(([z,_])=>{const C=z.match(/^on([A-Z][a-zA-Z]*)$/);C?p.addEventListener(C[1].toLowerCase(),_):p.setAttribute(z,_)});const $={canvas:p,params:e.params,antialias:e.antialias,alpha:e.alpha,autoClear:e.autoClear,orbitCtrl:e.orbitCtrl,pointer:e.pointer,resize:e.resize};e.width&&($.width=parseInt(e.width)),e.height&&($.height=parseInt(e.height));const E=Oi($);B(e,"props",E.renderer),ns(()=>{e.pixelRatio&&E.renderer.setPixelRatio(e.pixelRatio)});const v=()=>{};return{canvas:p,three:E,renderer:E.renderer,size:E.size,renderFn:v,raf:!0,initCallbacks:r,mountedCallbacks:s,beforeRenderCallbacks:i,afterRenderCallbacks:n,resizeCallbacks:o}},computed:{camera:{get:function(){return this.three.camera},set:function(e){this.three.camera=e}},scene:{get:function(){return this.three.scene},set:function(e){this.three.scene=e}},composer:{get:function(){return this.three.composer},set:function(e){this.three.composer=e}}},provide(){return{[R]:this}},mounted(){var e;this.$el.parentNode.insertBefore(this.canvas,this.$el),this.three.init()&&(this.three.pointer&&(this.$pointer=this.three.pointer),this.three.config.onResize=t=>{this.resizeCallbacks.forEach(r=>r({type:"resize",renderer:this,size:t}))},this.shadow&&(this.renderer.shadowMap.enabled=!0),this.renderFn=this.three.composer?this.three.renderC:this.three.render,this.initCallbacks.forEach(t=>t({type:"init",renderer:this})),(e=this.onReady)==null||e.call(this,this),this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.mountedCallbacks.forEach(t=>t({type:"mounted",renderer:this}))},beforeUnmount(){this.canvas.remove(),this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onInit(e){this.addListener("init",e)},onMounted(e){this.addListener("mounted",e)},onBeforeRender(e){this.addListener("beforerender",e)},offBeforeRender(e){this.removeListener("beforerender",e)},onAfterRender(e){this.addListener("afterrender",e)},offAfterRender(e){this.removeListener("afterrender",e)},onResize(e){this.addListener("resize",e)},offResize(e){this.removeListener("resize",e)},addListener(e,t){this.getCallbacks(e).push(t)},removeListener(e,t){const r=this.getCallbacks(e),s=r.indexOf(t);s!==-1&&r.splice(s,1)},getCallbacks(e){return e==="init"?this.initCallbacks:e==="mounted"?this.mountedCallbacks:e==="beforerender"?this.beforeRenderCallbacks:e==="afterrender"?this.afterRenderCallbacks:this.resizeCallbacks},render(e){this.beforeRenderCallbacks.forEach(t=>t({type:"beforerender",renderer:this,time:e})),this.renderFn({renderer:this,time:e}),this.afterRenderCallbacks.forEach(t=>t({type:"afterrender",renderer:this,time:e}))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Renderer"}),Ve=a({props:{props:{type:Object,default:()=>({})}},render(){return this.$slots.default?this.$slots.default():[]}});function ce(e,t,r,s=!0){e[t]=r,s&&e.updateProjectionMatrix()}var Ke=a({extends:Ve,name:"OrthographicCamera",props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:()=>({x:0,y:0,z:0})}},setup(e){const t=X(R);if(!t){console.error("Renderer not found");return}const r=new ms(e.left,e.right,e.top,e.bottom,e.near,e.far);return t.camera=r,y(e,"position",r),B(e,"props",r,!0,ce),["left","right","top","bottom","near","far","zoom"].forEach(s=>{u(()=>e[s],i=>{ce(r,s,i)})}),{renderer:t,camera:r}},__hmrId:"OrthographicCamera"}),le=a({extends:Ve,name:"PerspectiveCamera",props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:()=>({x:0,y:0,z:0})},lookAt:{type:Object,default:null}},setup(e){var t;const r=X(R);if(!r){console.error("Renderer not found");return}const s=new ps(e.fov,e.aspect,e.near,e.far);return r.camera=s,y(e,"position",s),e.lookAt&&s.lookAt((t=e.lookAt.x)!=null?t:0,e.lookAt.y,e.lookAt.z),u(()=>e.lookAt,i=>{var n;s.lookAt((n=i.x)!=null?n:0,i.y,i.z)},{deep:!0}),B(e,"props",s,!0,ce),["aspect","far","fov","near"].forEach(i=>{u(()=>e[i],n=>{ce(s,i,n)})}),{renderer:r,camera:s}},__hmrId:"PerspectiveCamera"});const me=Symbol("Scene");var Xe=a({name:"Scene",props:{background:[String,Number,Object]},setup(e){const t=X(R),r=new fs;if(!t){console.error("Renderer not found");return}t.scene=r,os(me,r);const s=i=>{!i||(typeof i=="string"||typeof i=="number"?r.background instanceof re?r.background.set(i):r.background=new re(i):i instanceof ys&&(r.background=i))};return s(e.background),u(()=>e.background,s),{scene:r,add:i=>{r.add(i)},remove:i=>{r.remove(i)}}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"});const $i={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function};var I=a({name:"Object3D",inject:{renderer:R,scene:me},emits:["created","ready"],props:{position:{type:Object,default:()=>({x:0,y:0,z:0})},rotation:{type:Object,default:()=>({x:0,y:0,z:0})},scale:{type:Object,default:()=>({x:1,y:1,z:1,order:"XYZ"})},lookAt:{type:Object,default:null},userData:{type:Object,default:()=>({})},visible:{type:Boolean,default:!0},props:{type:Object,default:()=>({})},disableAdd:{type:Boolean,default:!1},disableRemove:{type:Boolean,default:!1},...$i},setup(){return{}},created(){this.renderer||console.error("Missing parent Renderer"),this.scene||console.error("Missing parent Scene")},unmounted(){this.disableRemove||this.removeFromParent(),this.o3d&&this.renderer&&this.renderer.three.removeIntersectObject(this.o3d)},methods:{initObject3D(e){var t;this.o3d=e,e.userData.component=this,(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer&&this.renderer.three.addIntersectObject(e),y(this,"position",e),y(this,"rotation",e),y(this,"scale",e),y(this,"userData",e.userData),y(this,"visible",e),B(this,"props",e),this.$emit("created",e),this.lookAt&&e.lookAt((t=this.lookAt.x)!=null?t:0,this.lookAt.y,this.lookAt.z),u(()=>this.lookAt,r=>{var s;e.lookAt((s=r.x)!=null?s:0,r.y,r.z)},{deep:!0}),this.parent=this.getParent(),this.disableAdd||(this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)"))},getParent(){let e=this.$parent;if(!e){const t=as();t&&t.parent&&(e=t.parent.ctx)}for(;e;){if(e.add)return e;e=e.$parent}},addToParent(e){const t=e||this.o3d;return this.parent?(this.parent.add(t),!0):!1},removeFromParent(e){const t=e||this.o3d;return this.parent?(this.parent.remove(t),!0):!1},add(e){var t;(t=this.o3d)==null||t.add(e)},remove(e){var t;(t=this.o3d)==null||t.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),qe=a({name:"Group",extends:I,setup(){return{group:new gs}},created(){this.initObject3D(this.group)},__hmrId:"Group"});const V=()=>{};var We=a({name:"Raycaster",props:{onPointerEnter:{type:Function,default:V},onPointerOver:{type:Function,default:V},onPointerMove:{type:Function,default:V},onPointerLeave:{type:Function,default:V},onPointerUp:{type:Function,default:V},onPointerDown:{type:Function,default:V},onClick:{type:Function,default:V},intersectMode:{type:String,default:"move"},intersectRecursive:{type:Boolean,default:!1}},setup(){return{renderer:X(R)}},mounted(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer;this.renderer.onMounted(()=>{!e.camera||(this.pointer=Ue({camera:e.camera,domElement:e.canvas,intersectObjects:()=>e.scene?e.scene.children:[],intersectRecursive:this.intersectRecursive,onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectUp:this.onPointerUp,onIntersectDown:this.onPointerDown,onIntersectClick:this.onClick}),this.pointer.addListeners(),this.intersectMode==="frame"&&e.onBeforeRender(this.pointer.intersect))})},unmounted(){var e;this.pointer&&(this.pointer.removeListeners(),(e=this.renderer)==null||e.offBeforeRender(this.pointer.intersect))},render(){return[]},__hmrId:"Raycaster"}),Ze=a({extends:I,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean,hideMeshes:{type:Array,default:()=>[]}},setup(e){const t=X(R);if(!t||!t.scene)return console.error("Missing Renderer / Scene"),{};const r=t.renderer,s=t.scene,i=new bs(e.cubeRTSize,{format:vs,generateMipmaps:!0,minFilter:Ss}),n=new Ps(e.cubeCameraNear,e.cubeCameraFar,i),o=()=>{e.hideMeshes.forEach(p=>{p.visible=!1}),n.update(r,s),e.hideMeshes.forEach(p=>{p.visible=!0})};return e.autoUpdate?(t.onBeforeRender(o),hs(()=>{t.offBeforeRender(o)})):t.onMounted(o),{cubeRT:i,cubeCamera:n,updateRT:o}},created(){this.cubeCamera&&this.initObject3D(this.cubeCamera)},render(){return[]},__hmrId:"CubeCamera"});const Y=Symbol("Mesh"),K=a({name:"Mesh",extends:I,props:{castShadow:Boolean,receiveShadow:Boolean},setup(){return{}},provide(){return{[Y]:this}},mounted(){!this.mesh&&!this.loading&&this.initMesh()},methods:{initMesh(){const e=new ws(this.geometry,this.material);y(this,"castShadow",e),y(this,"receiveShadow",e),this.mesh=e,this.initObject3D(e)},createGeometry(){},addGeometryWatchers(e){Object.keys(e).forEach(t=>{u(()=>this[t],()=>{this.refreshGeometry()})})},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh&&this.geometry&&(this.mesh.geometry=this.geometry),e==null||e.dispose()}},unmounted(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()},__hmrId:"Mesh"});function G(e,t,r){return a({name:e,extends:K,props:t,created(){this.createGeometry(),this.addGeometryWatchers(t)},methods:{createGeometry(){this.geometry=r(this)}}})}const pe=a({emits:["created"],props:{rotateX:Number,rotateY:Number,rotateZ:Number,attributes:{type:Array,default:()=>[]}},inject:{mesh:Y},setup(){return{}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh.setGeometry(this.geometry),Object.keys(this.$props).forEach(e=>{u(()=>this[e],this.refreshGeometry)})},unmounted(){var e;(e=this.geometry)==null||e.dispose()},methods:{createGeometry(){const e={},t=new xs;this.attributes.forEach(r=>{if(r.name&&r.itemSize&&r.array){const s=e[r.name]=new Cs(r.array,r.itemSize,r.normalized);t.setAttribute(r.name,s)}}),t.computeBoundingBox(),t.userData.component=this,this.geometry=t,this.$emit("created",t)},rotateGeometry(){!this.geometry||(this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ))},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh&&this.mesh.setGeometry(this.geometry),e==null||e.dispose()}},render(){return[]}});function w(e,t,r){return a({name:e,extends:pe,props:t,methods:{createGeometry(){this.geometry=r(this),this.geometry.userData.component=this,this.$emit("created",this.geometry)}}})}const Ye={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function Je(e){return e.size?new Re(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new Re(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Qe=w("BoxGeometry",Ye,Je);const et={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function tt(e){return new Ms(e.radius,e.segments,e.thetaStart,e.thetaLength)}var rt=w("CircleGeometry",et,tt);const st={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function it(e){return new Gs(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var nt=w("ConeGeometry",st,it);const ot={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function at(e){return new Ls(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var ht=w("CylinderGeometry",ot,at);const dt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ut(e){return new Ns(e.radius,e.detail)}var ct=w("DodecahedronGeometry",dt,ut);const Ei={shapes:{type:[Object,Array]},options:{type:Object},positions:{type:Array,default:null}};function zi(e){if(Array.isArray(e.options)&&Array.isArray(e.shapes)){const t=e.shapes.map((r,s)=>{const i=new je(r,e.options[s]);return e.positions&&i.translate(e.positions[s].x,e.positions[s].y,e.positions[s].z),i});return di(t)}else return new je(e.shapes,e.options)}var lt=w("ExtrudeGeometry",Ei,zi);const mt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function pt(e){return new Os(e.radius,e.detail)}var ft=w("IcosahedronGeometry",mt,pt);const yt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2}};function gt(e){return new $s(e.points,e.segments,e.phiStart,e.phiLength)}var bt=w("LatheGeometry",yt,gt);const vt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function St(e){return new Es(e.radius,e.detail)}var Pt=w("OctahedronGeometry",vt,St);const wt={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function xt(e){return new Ie(e.width,e.height,e.widthSegments,e.heightSegments)}var Ct=w("PlaneGeometry",wt,xt);const Mt={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function Gt(e){return new zs(e.vertices,e.indices,e.radius,e.detail)}var Lt=w("PolyhedronGeometry",Mt,Gt);const Nt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ot(e){return new Rs(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var $t=w("RingGeometry",Nt,Ot);const Et={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI}};function zt(e){return new js(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}var Rt=w("SphereGeometry",Et,zt);const Ri={shapes:{type:[Object,Array]},curveSegments:{type:Number}};function ji(e){return new Is(e.shapes,e.curveSegments)}var jt=w("ShapeGeometry",Ri,ji);const It={radius:{type:Number,default:1},detail:{type:Number,default:0}};function kt(e){return new ks(e.radius,e.detail)}var _t=w("TetrahedronGeometry",It,kt);const Tt={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:Math.PI*2}};function At(e){return new _s(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Bt=w("TorusGeometry",Tt,At);const Dt={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function Ft(e){return new Ts(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var Ut=w("TorusKnotGeometry",Dt,Ft);const Me={points:Array,path:As,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function Ht(e){let t;return e.points?t=new ke(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new Bs(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var Vt=a({extends:pe,props:Me,methods:{createGeometry(){this.geometry=Ht(this)},updatePoints(e){Kt(this.geometry,e)}}});function Kt(e,t){const r=new ke(t),{radialSegments:s,radius:i,tubularSegments:n,closed:o}=e.parameters,p=r.computeFrenetFrames(n,o);e.tangents=p.tangents,e.normals=p.normals,e.binormals=p.binormals,e.parameters.path=r;const $=e.getAttribute("position"),E=e.getAttribute("normal"),v=new de,z=new de;for(let C=0;C<n;C++)_(C);_(n),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0;function _(C){r.getPointAt(C/n,z);const D=p.normals[C],F=p.binormals[C];for(let j=0;j<=s;j++){const T=j/s*Math.PI*2,U=Math.sin(T),h=-Math.cos(T);v.x=h*D.x+U*F.x,v.y=h*D.y+U*F.y,v.z=h*D.z+U*F.z,v.normalize();const d=C*(s+1)+j;E.setXYZ(d,v.x,v.y,v.z),$.setXYZ(d,z.x+i*v.x,z.y+i*v.y,z.z+i*v.z)}}}var J=a({extends:I,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:()=>({x:512,y:512})},shadowCamera:{type:Object,default:()=>({})}},setup(){return{}},unmounted(){(this.light instanceof Pe||this.light instanceof we)&&this.removeFromParent(this.light.target)},methods:{initLight(e){this.light=e,e.shadow&&(e.castShadow=this.castShadow,Z(e.shadow.mapSize,this.shadowMapSize),Z(e.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach(t=>{u(()=>this[t],r=>{t==="color"?e.color.set(r):e[t]=r})}),this.initObject3D(e),(e instanceof Pe||e instanceof we)&&(y(this,"target",e.target,"position"),this.addToParent(e.target))}},__hmrId:"Light"}),Xt=a({extends:J,created(){this.initLight(new Ds(this.color,this.intensity))},__hmrId:"AmbientLight"}),qt=a({extends:J,props:{target:{type:Object,default:()=>({x:0,y:0,z:0})}},created(){this.initLight(new we(this.color,this.intensity))},__hmrId:"DirectionalLight"}),Wt=a({extends:J,props:{groundColor:{type:String,default:"#444444"}},created(){const e=new Fs(this.color,this.groundColor,this.intensity);u(()=>this.groundColor,t=>{e.groundColor.set(t)}),this.initLight(e)},__hmrId:"HemisphereLight"}),Zt=a({extends:J,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.initLight(new Us(this.color,this.intensity,this.distance,this.decay))},__hmrId:"PointLight"}),Yt=a({extends:J,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){ui.init();const e=new Hs(this.color,this.intensity,this.width,this.height);if(["width","height"].forEach(t=>{u(()=>this[t],r=>{e[t]=r})}),this.helper){const t=new ci(e);e.add(t)}this.initLight(e)},__hmrId:"RectAreaLight"}),Jt=a({extends:J,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){const e=new Pe(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay);["angle","decay","distance","penumbra"].forEach(t=>{u(()=>this[t],r=>{e[t]=r})}),this.initLight(e)},__hmrId:"SpotLight"});const fe=Symbol("Material"),ye=a({emits:["created"],props:{color:{type:String,default:"#ffffff"},props:{type:Object,default:()=>({})}},inject:{mesh:Y},setup(){return{}},provide(){return{[fe]:this}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}if(this.createMaterial){const e=this.material=this.createMaterial();u(()=>this.color,t=>{e.color.set(t)}),B(this,"props",e,!1,this.setProp),this.$emit("created",e),this.mesh.setMaterial(e)}},unmounted(){var e;(e=this.material)==null||e.dispose()},methods:{getMaterialParams(){return{...ie(this.$props,["props"]),...this.props}},setProp(e,t,r,s=!1){const i=e[t];i instanceof re?i.set(r):e[t]=r,e.needsUpdate=s},setTexture(e,t="map"){this.setProp(this.material,t,e,!0)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});function k(e,t,r){return a({name:e,extends:ye,props:t,methods:{createMaterial(){return r(this.getMaterialParams())}}})}const Qt=k("BasicMaterial",{props:{type:Object,default:()=>({})}},e=>new _e(e)),er=k("LambertMaterial",{props:{type:Object,default:()=>({})}},e=>new Vs(e)),tr=k("PhongMaterial",{props:{type:Object,default:()=>({})}},e=>new Ks(e)),rr=k("PhysicalMaterial",{props:{type:Object,default:()=>({})}},e=>new Xs(e)),sr=k("PointsMaterial",{props:{type:Object,default:()=>({})}},e=>new qs(e)),ir=k("ShadowMaterial",{color:{type:String,default:"#000000"},props:{type:Object,default:()=>({})}},e=>new Ws(e)),nr=k("StandardMaterial",{props:{type:Object,default:()=>({})}},e=>new Zs(e)),or=k("ToonMaterial",{props:{type:Object,default:()=>({})}},e=>new Ys(e));var ar=k("MatcapMaterial",{src:String,name:{type:String,default:"0404E8_0404B5_0404CB_3333FC"}},e=>{const t=e.src?e.src:Ce(e.name),r=ie(e,["src","name"]);return r.matcap=new se().load(t),new Js(r)});const Ii=`
  varying vec2 vUv;
  void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`,ki=`
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);
  }
`;var hr=k("ShaderMaterial",{props:{type:Object,default:()=>({uniforms:{},vertexShader:Ii,fragmentShader:ki})}},e=>new xe(ie(e,["color"])));function _i(e,t,r){return e.split(t).join(r)}const Ti=q.meshphong_frag.slice(0,q.meshphong_frag.indexOf("void main() {")),Ai=q.meshphong_frag.slice(q.meshphong_frag.indexOf("void main() {")),Bi={uniforms:Te.merge([Qs.phong.uniforms,{thicknessColor:{value:new re(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`
    #define USE_UV
    ${q.meshphong_vert}
  `,fragmentShader:`
    #define USE_UV
    #define SUBSURFACE

    ${Ti}

    uniform float thicknessPower;
    uniform float thicknessScale;
    uniform float thicknessDistortion;
    uniform float thicknessAmbient;
    uniform float thicknessAttenuation;
    uniform vec3 thicknessColor;

    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {
      #ifdef USE_COLOR
        vec3 thickness = vColor * thicknessColor;
      #else
        vec3 thickness = thicknessColor;
      #endif
      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));
      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
    }
  `+Ai.replace("#include <lights_fragment_begin>",_i(q.lights_fragment_begin,"RE_Direct( directLight, geometry, material, reflectedLight );",`
        RE_Direct( directLight, geometry, material, reflectedLight );
        #if defined( SUBSURFACE ) && defined( USE_UV )
          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);
        #endif
      `))};var dr=a({extends:ye,props:{uniforms:{type:Object,default:()=>({diffuse:"#ffffff",thicknessColor:"#ffffff",thicknessDistortion:.4,thicknessAmbient:.01,thicknessAttenuation:.7,thicknessPower:2,thicknessScale:4})}},methods:{createMaterial(){const e=Bi,t=Te.clone(e.uniforms);return B(this,"uniforms",t,!0,(r,s,i)=>{const n=r[s].value;n instanceof re?n.set(i):r[s].value=i}),new xe({...e,lights:!0,...this.props,uniforms:t})}}}),ge=a({inject:{material:fe},props:{name:{type:String,default:"map"},uniform:String,src:String,onLoad:Function,onProgress:Function,onError:Function,props:{type:Object,default:()=>({})}},setup(){return{}},created(){this.refreshTexture(),u(()=>this.src,this.refreshTexture)},unmounted(){var e,t;(e=this.material)==null||e.setTexture(null,this.name),(t=this.texture)==null||t.dispose()},methods:{createTexture(){if(this.src)return new se().load(this.src,this.onLoaded,this.onProgress,this.onError)},initTexture(){!this.texture||(B(this,"props",this.texture),this.material&&(this.material.setTexture(this.texture,this.name),this.material.material instanceof xe&&this.uniform&&(this.material.material.uniforms[this.uniform]={value:this.texture})))},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.texture=this.createTexture(),this.initTexture()},onLoaded(e){var t;(t=this.onLoad)==null||t.call(this,e)}},render(){return[]}}),ur=a({extends:ge,props:{name:{type:String,default:"envMap"},path:{type:String,required:!0},urls:{type:Array,default:()=>["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},props:{type:Object,default:()=>({mapping:ei})}},created(){u(()=>this.path,this.refreshTexture),u(()=>this.urls,this.refreshTexture)},methods:{createTexture(){return new ti().setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)}}}),cr=a({extends:ge,props:{videoId:{type:String,required:!0}},created(){u(()=>this.videoId,this.refreshTexture)},methods:{createTexture(){const e=document.getElementById(this.videoId);return new ri(e)}}}),lr=G("Box",Ye,Je),mr=G("Circle",et,tt),pr=G("Cone",st,it),fr=G("Cylinder",ot,at),yr=G("Dodecahedron",dt,ut),gr=G("Icosahedron",mt,pt),br=G("Lathe",yt,gt),vr=G("Octahedron",vt,St),Sr=G("Plane",wt,xt),Pr=G("Polyhedron",Mt,Gt),wr=G("Ring",Nt,Ot),xr=G("Sphere",Et,zt),Cr=G("Tetrahedron",It,kt);const Di={text:{type:String,required:!0,default:"Text"},fontSrc:{type:String,required:!0},size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var Mr=a({extends:K,props:Di,setup(){return{}},created(){if(!this.fontSrc){console.error('Missing required prop: "font-src"');return}["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach(t=>{u(()=>this[t],()=>{this.font&&this.refreshGeometry()})});const e=new mi;this.loading=!0,e.load(this.fontSrc,t=>{this.loading=!1,this.font=t,this.createGeometry(),this.initMesh()})},methods:{createGeometry(){this.geometry=new li(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),this.align==="center"&&this.geometry.center()}}}),Gr=G("Torus",Tt,At),Lr=G("TorusKnot",Dt,Ft),Nr=a({extends:K,props:Me,created(){this.createGeometry(),this.addGeometryWatchers(Me)},methods:{createGeometry(){this.geometry=Ht(this)},updatePoints(e){Kt(this.geometry,e)}},__hmrId:"Tube"}),Or=a({emits:["loaded"],extends:K,props:{src:{type:String,required:!0},width:Number,height:Number,widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},keepSize:Boolean},setup(){return{}},created(){!this.renderer||(this.geometry=new Ie(1,1,this.widthSegments,this.heightSegments),this.material=new _e({side:si,map:this.loadTexture()}),u(()=>this.src,this.refreshTexture),["width","height"].forEach(e=>{u(()=>this[e],this.resize)}),this.resize(),this.keepSize&&this.renderer.onResize(this.resize))},unmounted(){var e;(e=this.renderer)==null||e.offResize(this.resize)},methods:{loadTexture(){return new se().load(this.src,this.onLoaded)},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.material&&(this.material.map=this.loadTexture(),this.material.needsUpdate=!0)},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded",e)},resize(){if(!this.renderer||!this.texture)return;const e=this.renderer.size,t=this.texture.image.width,r=this.texture.image.height,s=t/r;let i=1,n=1;this.width&&this.height?(i=this.width*e.wWidth/e.width,n=this.height*e.wHeight/e.height):this.width?(i=this.width*e.wWidth/e.width,n=i/s):this.height?(n=this.height*e.wHeight/e.height,i=n*s):s>1?i=n*s:n=i/s,this.mesh&&(this.mesh.scale.x=i,this.mesh.scale.y=n)}},__hmrId:"Image"}),$r=a({extends:K,props:{count:{type:Number,required:!0}},methods:{initMesh(){if(this.renderer){if(!this.geometry||!this.material)return console.error("Missing geometry and/or material"),!1;this.mesh=new te(this.geometry,this.material,this.count),this.mesh.userData.component=this,y(this,"castShadow",this.mesh),y(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)}}},__hmrId:"InstancedMesh"}),Er=a({extends:I,emits:["loaded"],props:{src:{type:String,required:!0}},setup(){return{}},created(){this.texture=new se().load(this.src,this.onLoaded),this.material=new ii({map:this.texture}),this.sprite=new ni(this.material),this.initObject3D(this.sprite)},unmounted(){var e,t;(e=this.texture)==null||e.dispose(),(t=this.material)==null||t.dispose()},methods:{onLoaded(){this.updateUV(),this.$emit("loaded")},updateUV(){if(!this.texture||!this.sprite)return;const e=this.texture.image.width,t=this.texture.image.height,r=e/t;let s=.5,i=.5;r>1?s=.5*r:i=.5/r;const n=this.sprite.geometry.attributes.position.array;n[0]=-s,n[1]=-i,n[5]=s,n[6]=-i,n[10]=s,n[11]=i,n[15]=-s,n[16]=i,this.sprite.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),zr=a({extends:I,setup(){return{}},provide(){return{[Y]:this}},mounted(){this.mesh=this.points=new oi(this.geometry,this.material),this.initObject3D(this.mesh)},methods:{setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)}}}),Rr=a({extends:I,emits:["before-load","load","progress","error"],props:{src:{type:String,required:!0}},data(){return{progress:0}},methods:{onLoad(e){this.$emit("load",e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),jr=a({extends:Rr,created(){const e=new pi;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t.scene)},this.onProgress,this.onError)}}),Ir=a({extends:Rr,created(){const e=new fi;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t)},this.onProgress,this.onError)}});const be=Symbol("Composer");var kr=a({setup(){return{renderer:X(R)}},provide(){return{[be]:this}},created(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer,t=new yi(this.renderer.renderer);this.composer=t,this.renderer.composer=t,e.addListener("init",()=>{e.renderer.autoClear=!1,this.resize(),e.addListener("resize",this.resize)})},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{addPass(e){var t;(t=this.composer)==null||t.addPass(e)},removePass(e){var t;(t=this.composer)==null||t.removePass(e)},resize(){this.composer&&this.renderer&&this.composer.setSize(this.renderer.size.width,this.renderer.size.height)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"EffectComposer"}),O=a({inject:{renderer:R,composer:be},emits:["ready"],setup(){return{}},created(){this.composer||console.error("Missing parent EffectComposer"),this.renderer||console.error("Missing parent Renderer")},unmounted(){var e,t,r;this.pass&&((e=this.composer)==null||e.removePass(this.pass),(r=(t=this.pass).dispose)==null||r.call(t))},methods:{initEffectPass(e){var t;this.pass=e,(t=this.composer)==null||t.addPass(e),this.$emit("ready",e)}},render(){return[]},__hmrId:"EffectPass"}),_r=a({extends:O,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new gi(this.renderer.scene,this.renderer.camera);this.initEffectPass(e)},__hmrId:"RenderPass"});const Tr={focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}};var Ar=a({extends:O,props:Tr,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.renderer.size.width,height:this.renderer.size.height},t=new bi(this.renderer.scene,this.renderer.camera,e);Object.keys(Tr).forEach(r=>{u(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"BokehPass"});const Br={noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}};var Dr=a({extends:O,props:Br,created(){const e=new vi(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);Object.keys(Br).forEach(t=>{u(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"FilmPass"}),Fr=a({extends:O,created(){var e;const t=new ue(Si);(e=this.renderer)==null||e.addListener("resize",this.resize),this.initEffectPass(t)},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{resize({size:e}){if(this.pass){const{resolution:t}=this.pass.material.uniforms;t.value.x=1/e.width,t.value.y=1/e.height}}},__hmrId:"FXAAPass"});const Ur={shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}};var Hr=a({extends:O,props:Ur,created(){if(!this.renderer)return;const e=new Pi(this.renderer.size.width,this.renderer.size.height,{});Object.keys(Ur).forEach(t=>{e.uniforms[t].value=this[t],u(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"HalftonePass"}),Vr=a({extends:O,created(){if(!this.renderer)return;const e=new wi(this.renderer.size.width,this.renderer.size.height);this.initEffectPass(e)},__hmrId:"SMAAPass"}),Kr=a({extends:O,props:{options:{type:Object,default:()=>({})}},created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new xi(this.renderer.scene,this.renderer.camera,this.renderer.size.width,this.renderer.size.height);Object.keys(this.options).forEach(t=>{e[t]=this.options[t]}),this.initEffectPass(e)},__hmrId:"SSAOPass"}),Xr={uniforms:{},vertexShader:`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,fragmentShader:`
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  `},qr={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new A},end:{value:new A},delta:{value:new A},texSize:{value:new A}},vertexShader:Xr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float blurRadius;
    uniform float gradientRadius;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 delta;
    uniform vec2 texSize;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;

      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));
      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;
      for (float t = -30.0; t <= 30.0; t++) {
          float percent = (t + offset - 0.5) / 30.0;
          float weight = 1.0 - abs(percent);
          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);
          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);

          /* switch to pre-multiplied alpha to correctly blur transparent images */
          texel.rgb *= texel.a;
          // texel2.rgb *= texel2.a;

          color += texel * weight;
          total += 2.0 * weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `};const Fi={blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:()=>({x:0,y:100})},end:{type:Object,default:()=>({x:10,y:100})}};var Wr=a({extends:O,props:Fi,setup(){return{uniforms1:{},uniforms2:{}}},created(){if(!this.composer)return;this.pass1=new ue(qr),this.pass2=new ue(qr);const e=this.uniforms1=this.pass1.uniforms,t=this.uniforms2=this.pass2.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,y(this,"blurRadius",e.blurRadius,"value"),y(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach(r=>{u(()=>this[r],this.updateFocusLine,{deep:!0})}),this.pass1.setSize=(r,s)=>{e.texSize.value.set(r,s)},this.initEffectPass(this.pass1),this.composer.addPass(this.pass2)},unmounted(){this.composer&&this.pass2&&this.composer.removePass(this.pass2)},methods:{updateFocusLine(){this.uniforms1.start.value.copy(this.start),this.uniforms1.end.value.copy(this.end);const e=new A().copy(this.end).sub(this.start).normalize();this.uniforms1.delta.value.copy(e),this.uniforms2.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"});const Zr={strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}};var Yr=a({extends:O,props:Zr,created(){if(!this.renderer)return;const e=new A(this.renderer.size.width,this.renderer.size.height),t=new Ci(e,this.strength,this.radius,this.threshold);Object.keys(Zr).forEach(r=>{u(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"UnrealBloomPass"}),Ui={uniforms:{tDiffuse:{value:null},center:{value:new A(.5,.5)},strength:{value:0}},vertexShader:Xr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }
    
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      vec2 toCenter = center - vUv;
      
      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
      
      for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        texel.rgb *= texel.a;

        color += texel * weight;
        total += weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `},Jr=a({extends:O,props:{center:{type:Object,default:()=>({x:.5,y:.5})},strength:{type:Number,default:.5}},created(){const e=new ue(Ui);y(this,"center",e.uniforms.center,"value"),y(this,"strength",e.uniforms.strength,"value"),this.initEffectPass(e)},__hmrId:"ZoomBlurPass"});const Hi={size:{type:Number,required:!0,default:100},divisions:{type:Number,required:!0,default:10},color1:{type:Number},color2:{type:Number}};var Qr=a({extends:I,name:"GridHelper",props:Hi,setup(){return{}},mounted(){this.helper||this.initHelper(),["size","divisions","color1","color2"].forEach(e=>{u(()=>this[e],()=>{this.refreshHelper()})})},unmounted(){this.destroyHelper()},methods:{initHelper(){this.helper=new ai(this.size,this.divisions,this.color1,this.color2),y(this,"castShadow",this.helper),y(this,"receiveShadow",this.helper),this.initObject3D(this.helper)},destroyHelper(){var e,t;this.helper&&this.removeFromParent(this.helper),(e=this.getParent())==null||e.remove(this.helper),(t=this.helper)==null||t.dispose()},refreshHelper(){this.destroyHelper(),this.initHelper()}}}),Vi=Object.freeze({__proto__:null,Renderer:He,RendererInjectionKey:R,OrthographicCamera:Ke,PerspectiveCamera:le,Camera:le,Group:qe,Scene:Xe,SceneInjectionKey:me,Object3D:I,Raycaster:We,CubeCamera:Ze,BufferGeometry:pe,BoxGeometry:Qe,CircleGeometry:rt,ConeGeometry:nt,CylinderGeometry:ht,DodecahedronGeometry:ct,ExtrudeGeometry:lt,IcosahedronGeometry:ft,LatheGeometry:bt,OctahedronGeometry:Pt,PlaneGeometry:Ct,PolyhedronGeometry:Lt,RingGeometry:$t,SphereGeometry:Rt,ShapeGeometry:jt,TetrahedronGeometry:_t,TorusGeometry:Bt,TorusKnotGeometry:Ut,TubeGeometry:Vt,AmbientLight:Xt,DirectionalLight:qt,HemisphereLight:Wt,PointLight:Zt,RectAreaLight:Yt,SpotLight:Jt,Material:ye,BasicMaterial:Qt,LambertMaterial:er,PhongMaterial:tr,PhysicalMaterial:rr,PointsMaterial:sr,ShadowMaterial:ir,StandardMaterial:nr,ToonMaterial:or,MaterialInjectionKey:fe,MatcapMaterial:ar,ShaderMaterial:hr,SubSurfaceMaterial:dr,Texture:ge,CubeTexture:ur,VideoTexture:cr,Mesh:K,MeshInjectionKey:Y,Box:lr,Circle:mr,Cone:pr,Cylinder:fr,Dodecahedron:yr,Icosahedron:gr,Lathe:br,Octahedron:vr,Plane:Sr,Polyhedron:Pr,Ring:wr,Sphere:xr,Tetrahedron:Cr,Text:Mr,Torus:Gr,TorusKnot:Lr,Tube:Nr,Image:Or,InstancedMesh:$r,Sprite:Er,Points:zr,GltfModel:jr,FbxModel:Ir,EffectComposer:kr,ComposerInjectionKey:be,RenderPass:_r,EffectPass:O,BokehPass:Ar,FilmPass:Dr,FXAAPass:Fr,HalftonePass:Hr,SMAAPass:Vr,SSAOPass:Kr,TiltShiftPass:Wr,UnrealBloomPass:Yr,ZoomBlurPass:Jr,GridHelper:Qr,applyObjectProps:W,bindObjectProp:B,bindObjectProps:Ae,setFromProp:Z,bindProps:Be,bindProp:y,propsValues:ie,lerp:De,limit:Fe,getMatcapUrl:Ce});const es={install(e){["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","CubeCamera","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","PointsMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","BufferGeometry","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Points","Sprite","FbxModel","GltfModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass"].forEach(t=>{e.component(t,Vi[t])})}};function Ki(e){return ds(e).use(es)}function Xi(){const e={loader:new se,count:0,textures:[],loadProgress:0,loadTextures:t,dispose:s};return e;function t(i,n){e.count=i.length,e.textures.splice(0),e.loadProgress=0,Promise.all(i.map(r)).then(n)}function r(i,n){return new Promise(o=>{e.loader.load(i.src,p=>{e.loadProgress+=1/e.count,e.textures[n]=p,o(p)})})}function s(){e.textures.forEach(i=>i.dispose())}}export{Xt as AmbientLight,Qt as BasicMaterial,Ar as BokehPass,lr as Box,Qe as BoxGeometry,pe as BufferGeometry,le as Camera,mr as Circle,rt as CircleGeometry,be as ComposerInjectionKey,pr as Cone,nt as ConeGeometry,Ze as CubeCamera,ur as CubeTexture,fr as Cylinder,ht as CylinderGeometry,qt as DirectionalLight,yr as Dodecahedron,ct as DodecahedronGeometry,kr as EffectComposer,O as EffectPass,lt as ExtrudeGeometry,Fr as FXAAPass,Ir as FbxModel,Dr as FilmPass,jr as GltfModel,Qr as GridHelper,qe as Group,Hr as HalftonePass,Wt as HemisphereLight,gr as Icosahedron,ft as IcosahedronGeometry,Or as Image,$r as InstancedMesh,er as LambertMaterial,br as Lathe,bt as LatheGeometry,ar as MatcapMaterial,ye as Material,fe as MaterialInjectionKey,K as Mesh,Y as MeshInjectionKey,I as Object3D,vr as Octahedron,Pt as OctahedronGeometry,Ke as OrthographicCamera,le as PerspectiveCamera,tr as PhongMaterial,rr as PhysicalMaterial,Sr as Plane,Ct as PlaneGeometry,Zt as PointLight,zr as Points,sr as PointsMaterial,Pr as Polyhedron,Lt as PolyhedronGeometry,We as Raycaster,Yt as RectAreaLight,_r as RenderPass,He as Renderer,R as RendererInjectionKey,wr as Ring,$t as RingGeometry,Vr as SMAAPass,Kr as SSAOPass,Xe as Scene,me as SceneInjectionKey,hr as ShaderMaterial,ir as ShadowMaterial,jt as ShapeGeometry,xr as Sphere,Rt as SphereGeometry,Jt as SpotLight,Er as Sprite,nr as StandardMaterial,dr as SubSurfaceMaterial,Cr as Tetrahedron,_t as TetrahedronGeometry,Mr as Text,ge as Texture,Wr as TiltShiftPass,or as ToonMaterial,Gr as Torus,Bt as TorusGeometry,Lr as TorusKnot,Ut as TorusKnotGeometry,es as TroisJSVuePlugin,Nr as Tube,Vt as TubeGeometry,Yr as UnrealBloomPass,cr as VideoTexture,Jr as ZoomBlurPass,W as applyObjectProps,B as bindObjectProp,Ae as bindObjectProps,y as bindProp,Be as bindProps,Ki as createApp,Ce as getMatcapUrl,De as lerp,Fe as limit,ie as propsValues,Z as setFromProp,Xi as useTextures};
//# sourceMappingURL=trois.module.cdn.min.js.map
